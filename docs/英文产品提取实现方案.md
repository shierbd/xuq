# English Template-Based Product Extraction Implementation Plan
# 英文模板化产品提取实现方案

**创建日期**: 2026-01-05
**版本**: v1.0
**目标**: 将模板化变量提取方法应用于英文电商产品挖掘

---

## 一、方法论对比分析

### 1.1 原文章方法论（中文闲鱼案例）

**核心思想**:
```
搜索模板包含变量 → 变量存在于多个模板中
种子词 → 提取模板 → 提取变量 → 迭代优化
```

**7步流程**:
1. 收集长尾关键词（60W+闲鱼关键词）
2. 计算词频统计
3. 选择高频词，组合主关键词
4. 使用5118工具批量提取
5. 加载全部数据
6. 人工筛选种子产品词
7. 用种子词提取模板
8. 用模板提取变量

**示例模板**:
- `XX怎么引流到微信` → 变量: 小红书、快手、视频号
- `抖音怎么拍XX视频` → 变量: 书单、影视、图文
- `闲鱼{变量}多少钱` → 变量: 产品名

**质量控制**:
- 模板出现频次越高 → 越有代表性
- 变量匹配模板越多 → 越可能正确
- 人工精选种子词保证准确性

---

### 1.2 当前项目方法论（英文关键词聚类）

**技术栈**:
- **Louvain聚类**: 68个聚类，模块度0.8730（优秀）
- **DeepSeek语义标注**: 100%成功率，平均置信度86.6
- **质量评分**: 自动化质量评估（size/diversity/consistency）
- **意图分析**: find_tool, learn_how, other

**优势**:
- ✅ 全自动化（无需人工筛选种子词）
- ✅ AI驱动（DeepSeek语义理解）
- ✅ 高质量聚类（模块度0.8730）
- ✅ 已有125,315条英文短语数据

**局限**:
- ⚠️ 未实现模板化变量提取
- ⚠️ 未识别搜索模式（如 "how to X", "best X for Y"）
- ⚠️ 未提取结构化产品/方法/工具

---

### 1.3 融合方案：Louvain聚类 + 模板化提取

**核心理念**:
```
第1层: Louvain聚类 (已完成) → 68个语义一致的聚类
第2层: 模板提取 (新增) → 每个聚类内识别搜索模板
第3层: 变量提取 (新增) → 从模板中提取产品/工具/方法
第4层: DeepSeek标注 (已完成) → AI语义理解和分类
```

**优势**:
- ✅ 结合聚类的自动化 + 模板的结构化
- ✅ 降低噪音（聚类内语义一致，模板更准确）
- ✅ 可扩展（支持中文和英文）
- ✅ AI增强（DeepSeek识别产品类型）

---

## 二、英文搜索模板模式库

### 2.1 电商产品搜索模板（E-commerce Product Patterns）

**产品查询模板**:
```python
PRODUCT_QUERY_PATTERNS = {
    # 产品推荐类
    "best_X_for_Y": "best {product} for {use_case}",
    # 例: best laptop for gaming, best camera for beginners

    "top_X_brands": "top {product} brands",
    # 例: top smartphone brands, top headphone brands

    "X_vs_Y": "{product_A} vs {product_B}",
    # 例: iphone vs samsung, macbook vs dell

    # 产品功能类
    "how_to_use_X": "how to use {product}",
    # 例: how to use ring light, how to use tripod

    "X_tutorial": "{product} tutorial",
    # 例: drone tutorial, 3d printer tutorial

    # 产品购买类
    "where_to_buy_X": "where to buy {product}",
    # 例: where to buy gaming chair, where to buy camera lens

    "X_price": "{product} price",
    # 例: iphone 15 price, macbook pro price

    "cheap_X": "cheap {product}",
    # 例: cheap laptop, cheap camera

    "X_on_sale": "{product} on sale",
    # 例: nintendo switch on sale, airpods on sale

    # 产品评测类
    "X_review": "{product} review",
    # 例: iphone 15 review, ps5 review

    "is_X_worth_it": "is {product} worth it",
    # 例: is airpods pro worth it, is macbook air worth it
}
```

**Amazon/eBay特定模板**:
```python
MARKETPLACE_PATTERNS = {
    "amazon_X": "amazon {product}",
    "ebay_X": "ebay {product}",
    "aliexpress_X": "aliexpress {product}",

    "X_on_amazon": "{product} on amazon",
    "X_coupon_code": "{product} coupon code",
    "X_discount": "{product} discount",
}
```

---

### 2.2 服务/工具搜索模板（Service/Tool Patterns）

**工具类模板**:
```python
TOOL_PATTERNS = {
    "free_X_tool": "free {service} tool",
    # 例: free video editor, free photo editor

    "online_X": "online {service}",
    # 例: online calculator, online converter

    "X_generator": "{content} generator",
    # 例: password generator, qr code generator

    "X_converter": "{format_A} to {format_B} converter",
    # 例: pdf to word converter, youtube to mp3 converter
}
```

**教程类模板**:
```python
TUTORIAL_PATTERNS = {
    "how_to_X": "how to {action}",
    # 例: how to edit videos, how to create website

    "X_for_beginners": "{skill} for beginners",
    # 例: coding for beginners, photography for beginners

    "learn_X": "learn {skill}",
    # 例: learn python, learn photoshop
}
```

---

### 2.3 当前数据验证（基于已有125K短语）

**已验证的高频模板**（从前端测试报告）:

| 聚类ID | 主题 | 模板模式 | 示例短语 |
|--------|------|----------|----------|
| 0 | Area Code | `{location} area code` | california area code, 818 area code |
| 7 | Tattoo Ideas | `{category} tattoo ideas` | small tattoo ideas, lion tattoo ideas |
| 6 | Discount Codes | `{brand} promo code` | doordash promo code, uber eats promo code |
| 2 | YouTube Download | `youtube to {format}` | youtube to mp3, youtube video downloader |

**发现**: 当前数据已包含大量模板化搜索，但未被提取为结构化变量！

---

## 三、实现方案设计

### 3.1 数据库扩展

**新增表1: SearchTemplate（搜索模板表）**
```sql
CREATE TABLE search_templates (
    template_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    cluster_id INT NOT NULL,  -- 关联聚类
    template_pattern VARCHAR(255) NOT NULL,  -- 模板模式，如 "best {X} for {Y}"
    template_type ENUM('product_query', 'service_tool', 'tutorial', 'price', 'review') NOT NULL,
    frequency INT DEFAULT 0,  -- 模板出现频次
    variable_count INT DEFAULT 0,  -- 提取到的变量数量
    quality_score FLOAT,  -- 模板质量分

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_cluster_id (cluster_id),
    INDEX idx_template_type (template_type),
    INDEX idx_frequency (frequency)
);
```

**新增表2: TemplateVariable（模板变量表）**
```sql
CREATE TABLE template_variables (
    variable_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    template_id BIGINT NOT NULL,  -- 关联模板
    variable_text VARCHAR(255) NOT NULL,  -- 变量值，如 "gaming", "laptop"
    variable_slot VARCHAR(50),  -- 变量位置，如 "{product}", "{use_case}"
    match_count INT DEFAULT 0,  -- 匹配模板数量
    total_volume BIGINT DEFAULT 0,  -- 总搜索量

    -- 产品特定字段
    product_category VARCHAR(100),  -- 产品类别（AI识别）
    is_verified BOOLEAN DEFAULT FALSE,  -- 人工验证标记

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (template_id) REFERENCES search_templates(template_id),
    INDEX idx_template_id (template_id),
    INDEX idx_variable_text (variable_text),
    INDEX idx_match_count (match_count)
);
```

**新增表3: ProductEntity（产品实体表）**
```sql
CREATE TABLE product_entities (
    product_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(255) NOT NULL UNIQUE,  -- 产品名称
    product_category VARCHAR(100),  -- 类别（手机、笔记本、相机等）
    product_type ENUM('physical_product', 'digital_service', 'software_tool', 'content') NOT NULL,

    -- 统计字段
    total_search_volume BIGINT DEFAULT 0,  -- 总搜索量
    template_match_count INT DEFAULT 0,  -- 匹配模板数量
    cluster_count INT DEFAULT 0,  -- 关联聚类数量

    -- AI标注
    llm_description TEXT,  -- DeepSeek产品描述
    commercial_value_score INT,  -- 商业价值评分 (0-100)

    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_product_category (product_category),
    INDEX idx_commercial_value (commercial_value_score)
);
```

---

### 3.2 核心算法实现

**新增模块: `core/template_extractor.py`**

```python
"""
Template Extractor - 模板提取器
功能: 从聚类中提取搜索模板和变量
"""
from typing import List, Dict, Tuple
import re
from collections import Counter
from storage.repository import ClusterMetaRepository, PhraseRepository

class TemplateExtractor:
    """模板提取器"""

    def __init__(self):
        self.pattern_library = self._load_pattern_library()

    def _load_pattern_library(self) -> Dict[str, List[str]]:
        """加载预定义模板模式库"""
        return {
            # 产品查询类
            "product_query": [
                r"best (.+?) for (.+)",  # best X for Y
                r"top (.+?) (brands|models)",  # top X brands
                r"(.+?) vs (.+)",  # X vs Y
                r"(.+?) review",  # X review
            ],

            # 价格类
            "price": [
                r"(.+?) price",  # X price
                r"cheap (.+)",  # cheap X
                r"(.+?) on sale",  # X on sale
                r"(.+?) coupon code",  # X coupon code
            ],

            # 工具类
            "service_tool": [
                r"free (.+?) (tool|app|software)",  # free X tool
                r"online (.+)",  # online X
                r"(.+?) (generator|converter)",  # X generator
                r"(.+?) to (.+?) converter",  # X to Y converter
            ],

            # 教程类
            "tutorial": [
                r"how to (.+)",  # how to X
                r"(.+?) tutorial",  # X tutorial
                r"(.+?) for beginners",  # X for beginners
                r"learn (.+)",  # learn X
            ],
        }

    def extract_templates_from_cluster(
        self,
        cluster_id: int,
        phrases: List[str]
    ) -> List[Dict]:
        """从聚类中提取模板"""

        templates = []

        # 遍历所有模板模式
        for template_type, patterns in self.pattern_library.items():
            for pattern in patterns:
                matches = self._find_pattern_matches(phrases, pattern)

                if len(matches) >= 3:  # 至少3个短语匹配才认为是有效模板
                    template_info = {
                        'cluster_id': cluster_id,
                        'template_pattern': pattern,
                        'template_type': template_type,
                        'frequency': len(matches),
                        'matched_phrases': matches,
                        'variables': self._extract_variables(matches, pattern)
                    }
                    templates.append(template_info)

        return templates

    def _find_pattern_matches(
        self,
        phrases: List[str],
        pattern: str
    ) -> List[str]:
        """查找匹配模板的短语"""
        matches = []
        regex = re.compile(pattern, re.IGNORECASE)

        for phrase in phrases:
            if regex.search(phrase):
                matches.append(phrase)

        return matches

    def _extract_variables(
        self,
        matched_phrases: List[str],
        pattern: str
    ) -> Dict[str, List[str]]:
        """从匹配的短语中提取变量"""
        regex = re.compile(pattern, re.IGNORECASE)
        variables = {}

        for phrase in matched_phrases:
            match = regex.search(phrase)
            if match:
                for i, group in enumerate(match.groups(), 1):
                    slot = f"var{i}"
                    if slot not in variables:
                        variables[slot] = []
                    variables[slot].append(group.strip())

        # 统计变量频次
        for slot in variables:
            counter = Counter(variables[slot])
            variables[slot] = [
                {'text': var, 'count': count}
                for var, count in counter.most_common()
            ]

        return variables

    def extract_product_entities(
        self,
        variables: Dict[str, List[Dict]]
    ) -> List[Dict]:
        """从变量中提取产品实体"""
        products = []

        # 假设var1通常是产品名
        if 'var1' in variables:
            for var_info in variables['var1']:
                product = {
                    'product_name': var_info['text'],
                    'match_count': var_info['count'],
                    'confidence': self._calculate_product_confidence(var_info)
                }
                products.append(product)

        return products

    def _calculate_product_confidence(self, var_info: Dict) -> float:
        """计算产品置信度"""
        # 出现频次越高，置信度越高
        count = var_info['count']

        if count >= 10:
            return 0.95
        elif count >= 5:
            return 0.85
        elif count >= 3:
            return 0.70
        else:
            return 0.50


def run_template_extraction_pipeline():
    """运行模板提取流程"""

    print("="*70)
    print("Phase 2D: Template-Based Variable Extraction".center(70))
    print("="*70)

    extractor = TemplateExtractor()

    # 1. 加载所有聚类
    print("\n[Step 1] Loading clusters...")
    with ClusterMetaRepository() as meta_repo:
        clusters = meta_repo.session.query(ClusterMeta).filter(
            ClusterMeta.cluster_level == 'A'
        ).all()

    print(f"✓ Loaded {len(clusters)} clusters")

    # 2. 对每个聚类提取模板
    all_templates = []

    with PhraseRepository() as phrase_repo:
        for cluster in clusters:
            print(f"\n[Processing] Cluster {cluster.cluster_id}...")

            # 获取聚类短语
            phrases_db = phrase_repo.session.query(Phrase).filter(
                Phrase.cluster_id_A == cluster.cluster_id
            ).all()

            phrases = [p.phrase for p in phrases_db]

            # 提取模板
            templates = extractor.extract_templates_from_cluster(
                cluster.cluster_id,
                phrases
            )

            if templates:
                print(f"  ✓ Found {len(templates)} templates")
                all_templates.extend(templates)
            else:
                print(f"  - No templates found")

    # 3. 保存结果到数据库
    print(f"\n[Step 2] Saving {len(all_templates)} templates to database...")
    # TODO: 实现数据库保存逻辑

    print("\n" + "="*70)
    print("✅ Template extraction completed!".center(70))
    print("="*70)
```

---

### 3.3 DeepSeek AI增强

**新增模块: `core/product_labeling.py`**

```python
"""
Product Labeling - 产品AI标注
功能: 使用DeepSeek为提取的产品实体生成描述和分类
"""
from core.llm_client import LLMClient

class ProductLabeler:
    """产品标注器"""

    def __init__(self):
        self.llm = LLMClient(provider="deepseek")

    def label_product(self, product_name: str, context_phrases: List[str]) -> Dict:
        """为产品生成AI标注"""

        prompt = f"""
Analyze the following product extracted from search queries:

Product: {product_name}

Context (sample search phrases):
{chr(10).join(context_phrases[:10])}

Please provide:
1. Product category (e.g., Electronics/Camera, Software/Design Tool, Service/Cloud Storage)
2. Brief description (1-2 sentences)
3. Commercial value score (0-100, based on search interest and market demand)
4. Target audience (who searches for this?)

Return as JSON:
{{
  "product_category": "...",
  "description": "...",
  "commercial_value_score": 85,
  "target_audience": "..."
}}
"""

        response = self.llm.chat_completion(
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )

        # 解析JSON响应
        import json
        result = json.loads(response)

        return {
            'product_name': product_name,
            'product_category': result['product_category'],
            'llm_description': result['description'],
            'commercial_value_score': result['commercial_value_score'],
            'target_audience': result.get('target_audience', '')
        }
```

---

## 四、实施路线图

### Phase 1: 数据库扩展（1天）
- [x] 设计表结构
- [ ] 创建迁移脚本 `scripts/migrate_add_template_tables.py`
- [ ] 执行迁移，验证表创建成功
- [ ] 更新 `storage/models.py` 添加ORM模型

### Phase 2: 模板提取核心逻辑（2-3天）
- [ ] 实现 `core/template_extractor.py`
- [ ] 创建英文模板模式库（至少20个常见模式）
- [ ] 编写单元测试验证提取准确性
- [ ] 在现有68个聚类上试运行

### Phase 3: 变量提取与产品识别（2天）
- [ ] 实现变量提取逻辑
- [ ] 实现产品实体去重和聚合
- [ ] 计算产品质量分（基于频次、覆盖度）
- [ ] 创建Repository层 `ProductEntityRepository`

### Phase 4: DeepSeek AI增强（1-2天）
- [ ] 实现 `core/product_labeling.py`
- [ ] 为提取的产品生成AI描述
- [ ] 识别产品类别和商业价值
- [ ] 批量标注脚本 `scripts/run_phase2d_label_products.py`

### Phase 5: UI集成（2-3天）
- [ ] 创建 `ui/pages/phase2d_templates.py` 页面
- [ ] 展示提取的模板和变量
- [ ] 添加产品实体查看功能
- [ ] 支持产品导出（CSV/JSON）

### Phase 6: 验证与优化（1-2天）
- [ ] 在真实数据上验证准确率
- [ ] 人工审核Top 100产品
- [ ] 优化模板模式库
- [ ] 性能优化（批量处理、缓存）

**总计**: 约10-15天开发时间

---

## 五、预期成果

### 5.1 定量指标

**基于当前68个聚类，预估**:
- 提取模板数: 150-300个
- 提取产品实体: 500-1,000个
- 高置信度产品 (>0.8): 200-400个
- 商业价值产品 (>70分): 100-200个

**成本预估**:
- DeepSeek API调用: 约1,000次（标注产品）
- 成本: <$0.10 USD
- 运行时间: 10-15分钟

---

### 5.2 定性价值

**对比原文章方法**:

| 维度 | 原文章（中文手工） | 本方案（英文自动化） |
|------|-------------------|---------------------|
| 数据规模 | 60W闲鱼关键词 | 12.5W英文关键词 |
| 种子词选择 | 人工筛选 | Louvain聚类自动分组 |
| 模板提取 | 手工正则 | 预定义模式库+自动匹配 |
| 变量识别 | 频次统计 | 频次+AI语义理解 |
| 产品分类 | 人工分类 | DeepSeek自动分类 |
| 商业价值 | 人工评估 | AI评分+搜索量加权 |
| 可扩展性 | 低（依赖5118工具） | 高（通用框架） |

**独特优势**:
1. ✅ **双语支持**: 同样的框架可处理中文和英文
2. ✅ **自动化**: 从聚类→模板→变量→产品，全流程自动
3. ✅ **AI增强**: DeepSeek理解产品语义，而非仅统计频次
4. ✅ **质量控制**: 多层质量评分（聚类质量+模板质量+产品置信度）
5. ✅ **可追溯**: 产品→变量→模板→聚类→原始短语，完整链路

---

### 5.3 实际应用场景

**电商选品**:
- 识别高搜索量产品（如 "gaming laptop", "ring light"）
- 发现新兴产品（低竞争高搜索）
- 竞品分析（"X vs Y"模板）

**内容创作**:
- 识别热门教程需求（"how to X"）
- 发现知识盲点（高搜索+低内容）

**广告投放**:
- 识别高商业价值关键词
- 优化广告文案（基于搜索模板）

**市场研究**:
- 用户需求分析（意图分类）
- 产品趋势预测（搜索量变化）

---

## 六、技术风险与缓解

### 6.1 风险1: 模板模式不完整

**风险**: 预定义模板无法覆盖所有搜索模式

**缓解**:
- 迭代优化：从数据中学习新模板
- 支持自定义模板：用户可添加领域特定模式
- 使用LLM辅助：让DeepSeek识别新模板

---

### 6.2 风险2: 变量提取准确率

**风险**: 正则匹配可能误提取或漏提取变量

**缓解**:
- 多模板交叉验证：同一变量出现在多个模板中才认为有效
- 频次过滤：低频变量（<3次）标记为低置信度
- AI校验：DeepSeek验证变量是否为真实产品

---

### 6.3 风险3: 中英文差异

**风险**: 英文搜索模式与中文不同

**缓解**:
- 独立模式库：英文和中文使用不同的模板库
- 数据验证：在真实数据上测试准确率
- 逐步迭代：先支持英文常见模式，再扩展

---

## 七、与原文章的区别总结

| 对比项 | 原文章方法 | 本实现方案 |
|--------|-----------|-----------|
| **数据来源** | 5118工具导出 | 已有125K英文短语 |
| **聚类方法** | 无聚类，直接处理全量 | Louvain预聚类（68组） |
| **种子词** | 人工筛选产品词 | 聚类自动分组 |
| **模板提取** | 手工编写正则 | 预定义模式库 |
| **变量质量** | 仅频次统计 | 频次+置信度+AI验证 |
| **产品识别** | 人工分类 | DeepSeek自动分类 |
| **商业价值** | 无评估 | AI评分（0-100） |
| **语言** | 中文（闲鱼） | 英文（Amazon/eBay） |
| **可扩展性** | 依赖外部工具 | 通用框架 |
| **自动化程度** | 50%（需人工介入） | 95%（仅需验证） |

**核心创新点**:
1. **聚类优先**: 先用Louvain分组，再在组内提取模板（降低噪音）
2. **AI驱动**: DeepSeek理解产品语义，而非仅统计
3. **双语框架**: 同一套代码支持中英文
4. **全自动化**: 从原始数据到产品实体，无需人工介入

---

## 八、下一步行动

### 立即执行（高优先级）:

1. **确认需求范围** 💬
   - 是否只做英文，还是中英文双支持？
   - 优先支持哪些产品类别（电子产品、软件工具、服务）？
   - 预期产品数量级（Top 100? Top 500?）

2. **创建数据库迁移脚本** 🔧
   - `scripts/migrate_add_template_tables.py`
   - 添加3张新表: search_templates, template_variables, product_entities

3. **实现核心模板提取器** 🔧
   - `core/template_extractor.py`
   - 先支持10个最常见英文模板

4. **在1个聚类上试运行** 🧪
   - 选择Cluster 7（Tattoo Ideas）验证
   - 验证模板提取准确性

---

## 九、技术文档参考

**相关文档**:
- `docs/前端测试报告.md` - 当前系统状态
- `docs/完整测试总结报告.md` - 聚类质量验证
- 原文章: 《实操案例：电商产品快速提取！》

**相关代码**:
- `core/clustering.py` - Louvain聚类实现
- `core/cluster_labeling.py` - DeepSeek标注实现
- `storage/models.py` - 数据库ORM模型

---

**文档版本**: v1.0
**创建时间**: 2026-01-05
**状态**: 待讨论与确认
